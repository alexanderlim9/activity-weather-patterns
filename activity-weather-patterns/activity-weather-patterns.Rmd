---
title: "R Notebook"
output: html_notebook
---
Objective: Determine trends in activity patterns with respect to both weather and routine to predict and inform/improve future behavior.

Install packages.
```{r}
devtools::install_github("avsecz/fitbitr")
devtools::install_github("r-lib/httr#485")
install.packages("jsonlite")
install.packages("mongolite")
install.packages("lubridate")
install.packages("RCurl")
install.packages("XML")
install.packages("ggplot2")
install.packages("Metrics")

```
Load packages.
```{r}
library("fitbitr")
library("httr")  
library("jsonlite")
library("mongolite")
library("lubridate")
library("RCurl")
library("XML")
library("ggplot2")
library("Metrics")
token <- get_fitbit_token()
```

Pull raw activity data (JSON) from Fitbit API from 2016-06-23 (when I first began wearing the fitbit) to present.
```{r}
req <-
fitbit_GET("1/user/4QXD3G/activities/steps/date/2016-06-23/2017-12-02.json",
token = token)

output <- toJSON(fitbit_parse(req))
output
# ts <- ts(rev(output$sleep$minutesAsleep), start=c(1, 1), end=c(19, 1), frequency=1)
```
Convert JSON to data frame.
```{r}
output <- fromJSON(output, simplifyDataFrame = TRUE)
output
```
Clean activity data. Unlist JSON elements into columns. Convert data types and rename value column.
```{r}
data <- output$`activities-steps`
data$dateTime <- unlist(data$dateTime)
data$stepCount <- unlist(data$stepCount)
data

colnames(data)[2] <- "stepCount"
data$dateTime <- as.Date(data$dateTime, "%Y-%m-%d")
data$stepCount <- as.integer(data$stepCount)
```

Add additional date information features for day of the week and number week of the year.
```{r}
day <- weekdays(data$dateTime)
week <- week(data$dateTime)
data <- cbind(data, day, week)
data
```
Histogram representing distribution of daily step counts. The histogram shows a normal distribution.
```{r}
qplot(data$stepCount,
      geom="histogram",
      binwidth=500)
```

Create function to scrape weather data from https://www.wunderground.com/ for a given time period.
(The source is unable to provide history for very large periods of time and therefore must be retrieved in batches).
```{r}
getUrl <- function (date1, date2) {
  # Assemble proper url to retrieve weather data from webpage.
  # Arguments: date1, date2 are strings representing the start and end date in the format 'YYYY/mm/dd'
  # Returns: the customized url

  URL <-
  paste(
  "https://www.wunderground.com/history/airport/KBOS/",
  date1,
  "/CustomHistory.html?dayend=",
  substr(date2, 9, 10),
  "&monthend=",
  substr(date2, 6, 7),
  "&yearend=",
  substr(date2, 1, 4),
  "&req_city=&req_state=&req_statename=&reqdb.zip=&reqdb.magic=&reqdb.wmo=",
  sep = ""
  )
  return (URL)
}

fetchWeather <- function(startDate, endDate) {
  # Retrieve weather data for a given date range from webpage.
  # Arguments: startDate, endDate are strings representing the start and end date in the format 'YYYY/mm/dd'
  # Returns: a data frame containing the date, temperature, humidity, wind, precipitation, and types of weather

  webpage <-
    RCurl::getURL(getUrl(startDate, endDate))
  tc <- textConnection(webpage)
  webpage <- readLines(tc)
  close(tc)

  pagetree <- htmlTreeParse(webpage, useInternalNodes = TRUE)
  weatherDate <-
  unlist(xpathApply(pagetree, "//*[@id='obsTable']/tbody/tr/td[1]/a", xmlValue))

  weatherTempHi <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[2]/span",
  xmlValue
  ))

  weatherTempLo <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[4]/span",
  xmlValue
  ))

  weatherHumidity <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[9]/span",
  xmlValue
  ))

  weatherWind <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[18]/span",
  xmlValue
  ))

  weatherPrecip <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[20]/span",
  xmlValue
  ))

  weatherType <-
  unlist(xpathApply(pagetree, "//*[@id='obsTable']/tbody/tr/td[21]", xmlValue))

  # cleaning
  weatherType <-
  weatherType[grepl("\n", weatherType)] # remove empty strings
  weatherType <- gsub("\n", "", weatherType)
  weatherType <- gsub("\t", "", weatherType)

  weatherType
  weatherRain <- grepl("Rain", weatherType)
  weatherThunder <- grepl("Thunderstorm", weatherType)
  weatherFog <- grepl("Fog", weatherType)
  weatherSnow <- grepl("Snow", weatherType)

  weatherFrame <-
  data.frame(
  weatherDate,
  weatherTempHi,
  weatherTempLo,
  weatherHumidity,
  weatherWind,
  weatherPrecip,
  weatherType,
  weatherRain,
  weatherThunder,
  weatherFog,
  weatherSnow,
  stringsAsFactors = FALSE)

  weatherFrame[, 1:6] <- sapply(weatherFrame[, 1:6], as.numeric)

  colnames(weatherFrame) <-
  c("date",
  "tempHi",
  "tempLo",
  "avgHumidity",
  "avgWind",
  "precip",
  "type",
  "rain",
  "thunder",
  "fog",
  "snow")

  return(weatherFrame)
}

weather2016 <- fetchWeather("2016/06/23", "2017/06/22")
weather2017 <- fetchWeather("2017/06/23", "2017/12/02")
weatherTotal <- rbind(weather2016, weather2017)
weatherTotal
```

Merge activity data frame with weather data frame.
```{r}
data <- cbind(data, weatherTotal[,2:11])
data
```

Check for missing values. Only the precipitation column contains missing values.
```{r}
sapply(data[,1:14], function(x) length(x[which(is.na(x) == TRUE)]))
```

Exploratory visuals for precipitation.
```{r}
# precipitation over a one year period
plot(weather2016$precip, xlab="days since 2016/06/23", ylab="precipitation (in)")
# distribution of precipitation amounts
qplot(weatherTotal$precip,
      geom="histogram")
# distribution of non-zero precipitation amounts
qplot(weatherTotal$precip[which(weatherTotal$precip>0)],
      geom="histogram")
```

Partition data into training and validation sets.
```{r}
set.seed(200)
sampleRows <- sample.int(nrow(data), size = nrow(data)*.75)
sampleRows

trainingData <- data[sampleRows,]
trainingData <- trainingData[complete.cases(trainingData),]
trainingData

validationData <- data[-sampleRows,]
validationData <- validationData[complete.cases(validationData),]
validationData
```

Create regression model to impute missing precipitation data.
```{r}
plot(data$precip, data$avgHumidity)
plot(data$precip, data$avgWind)

pred <- lm(precip ~
             week +
             tempHi +
             tempLo +
             avgHumidity +
             avgWind +
             type +
             rain +
             thunder +
             fog +
             snow,
             data = trainingData)
summary(pred)
```
Backfit the model to remove statistically insignificant variables.
```{r}
pred <- lm(precip ~
             tempHi +
             tempLo +
             avgHumidity +
             avgWind +
             type,
             data = trainingData)
summary(pred)
```

```{r}
pred <- lm(precip ~
             avgHumidity +
             avgWind +
             type,
             data = trainingData)
summary(pred)
```

```{r}
pred <- lm(precip ~
             avgHumidity +
             avgWind,
             data = trainingData)
summary(pred)
```

Determine accuracy of imputation model for precipitation to be 54.26%. 
While the model is not statistically powerful with a low adjusted r-squared value .241, it serves the purpose of imputing missing precipation values.
```{r}
predAccuracy <- round(predict(pred, trainingData, type="response"))
accuracy(predAccuracy, validationData$precip)
```

Impute missing precipitation value.
```{r}
imputePrecip <- function(r) {
  # Given a row containing missing precipitation data, impute the missing value.
  # Arguments: row containing missing precip data
  # Returns: the predicted precipitation value for the entry
  
  precipPred <- (pred$coefficients[[1]] +
  (pred$coefficients[[2]] * r[7]) + (pred$coefficients[[3]] * r[8]))
  return(round(max(precipPred, 0), 2))
}

isWeatherEvent <- function(x) {
  # Determine if a particular date had a recorded weather event.
  # Arguments: string representing the 'type' field of the entry
  # Returns: true if the string matches any of the weather event types
  # Weather types  are hardcoded and this function should be abstracted to include all possible combinations more programmatically
  
  return(
  x == "Rain" |
  x == "Thunderstorm" |
  x == "Fog" |
  x == "Snow" |
  x == "Fog,Rain" |
  x == "Rain,Thunderstorm" |
  x == "Fog,Rain,Thunderstorm" |
  x == "Fog,Rain,Snow" |
  x == "Fog,Snow" |
  x == "Rain,Snow" |
  x == "Rain,Snow,Thunderstorm"
  )
}

# for data points where no weather events were recorded, impute precipitation of 0.00 if precipitation is NA
data[which(!isWeatherEvent(data$type)), ][is.na(data[which(!isWeatherEvent(data$type)), ]$precip), ]$precip <- 0.00

# for data points where a weather event was recorded, impute precipitation
incompleteCases <- data[is.na(data$precip), ]
imputedPrecip <- sapply(1:34, function(x) imputePrecip(incompleteCases[x, ])[[1]])
data[is.na(data$precip), ]$precip <- imputedPrecip

sapply(data[, 1:14], function(x)
length(x[which(is.na(x) == TRUE)])) # confirm that there are no remaining missing values
data
```

Detect outliers where stepCount is greater than or less than 3 standard deviations away from the mean.
```{r}
dataWOutliers <- data # make a copy of the data before removing outliers
dataMean <- mean(data$stepCount) # 10165.07
dataSd <- sd(data$stepCount) # 4223.689
outliers <- data[which((data$stepCount > (dataMean + 3 * dataSd)) |
(data$stepCount < (dataMean - 3 * dataSd))), ]
outliers
```

Remove outliers.
```{r}
data <-
  data[-which((data$stepCount > (dataMean + 3 * dataSd)) |
  (data$stepCount < (dataMean - 3 * dataSd))),]
  data
```

After removing outliers, the data shows a bell curve revealing a more normal distribution.
```{r}
qplot(data$stepCount,
      geom="histogram",
      binwidth=500)
```


Establish connection and insert data into mongodb collection.
```{r}
db <- mongo(collection = "activityWeatherCol", db = "activityWeatherdb", url = "mongodb://localhost")
# clear collection if already populated
if(db$count > 0) {
  db$drop()
}
db$insert(data)
```


From the multiple regression model of stepCount by temperature there seems to be no strong correlation with an adjusted R-squared value of -.002 and p-value of .590.
```{r}
stepsTempFrame <- db$find('{}', '{"stepCount":true, "tempHi":true, "tempLo":true, "_id":false}')

set.seed(200)
sampleRows <- sample.int(nrow(stepsTempFrame), size = nrow(stepsTempFrame)*.75)
sampleRows

trainingData <- stepsTempFrame[sampleRows,]
trainingData <- trainingData[complete.cases(trainingData),]
trainingData

validationData <- stepsTempFrame[-sampleRows,]
validationData <- validationData[complete.cases(validationData),]
validationData

pred <- lm(stepCount ~
             tempHi +
             tempLo,
             data = trainingData)
summary(pred)
predAccuracy <- round(predict(pred, trainingData, type="response"))
accuracy(predAccuracy, validationData$stepCount)
```








