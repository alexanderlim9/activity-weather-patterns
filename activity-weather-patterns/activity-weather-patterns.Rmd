---
title: "R Notebook"
output: html_notebook
---
Objective: Determine trends in activity patterns with respect to both weather and routine to predict and inform/improve future behavior.

Install packages.
```{r}
devtools::install_github("avsecz/fitbitr")
devtools::install_github("r-lib/httr#485")
install.packages("jsonlite")
install.packages("mongolite")
install.packages("lubridate")
install.packages("RCurl")
install.packages("XML")
install.packages("ggplot2")
install.packages("Metrics")

```
Load packages.
```{r}
library("fitbitr")
library("httr")  
library("jsonlite")
library("mongolite")
library("lubridate")
library("RCurl")
library("XML")
library("ggplot2")
library("Metrics")
token <- get_fitbit_token()
```

Pull raw activity data (JSON) from Fitbit API from 2016-06-23 (when I first began wearing the fitbit) to present.
```{r}
req <-
fitbit_GET("1/user/4QXD3G/activities/steps/date/2016-06-23/2017-12-02.json",
token = token)

output <- toJSON(fitbit_parse(req))
output
# ts <- ts(rev(output$sleep$minutesAsleep), start=c(1, 1), end=c(19, 1), frequency=1)
```
Convert JSON to data frame.
```{r}
output <- fromJSON(output, simplifyDataFrame = TRUE)
output
```
Clean activity data. Unlist JSON elements into columns. Convert data types and rename value column.
```{r}
data <- output$`activities-steps`
data$dateTime <- unlist(data$dateTime)
data$stepCount <- unlist(data$stepCount)
data

colnames(data)[2] <- "stepCount"
data$dateTime <- as.Date(data$dateTime, "%Y-%m-%d")
data$stepCount <- as.integer(data$stepCount)
```

Add additional date information features for day of the week and number week of the year.
```{r}
day <- weekdays(data$dateTime)
week <- week(data$dateTime)
data <- cbind(data, day, week)
data
```
Histogram representing distribution of daily step counts. The histogram shows a normal distribution.
```{r}
qplot(data$stepCount,
      geom="histogram",
      binwidth=500)
```

Create function to scrape weather data from https://www.wunderground.com/ for a given time period.
(The source is unable to provide history for very large periods of time and therefore must be retrieved in batches).
```{r}
getUrl <- function (date1, date2) {
  # Assemble proper url to retrieve weather data from webpage.
  # Arguments: date1, date2 are strings representing the start and end date in the format 'YYYY/mm/dd'
  # Returns: the customized url

  URL <-
  paste(
  "https://www.wunderground.com/history/airport/KBOS/",
  date1,
  "/CustomHistory.html?dayend=",
  substr(date2, 9, 10),
  "&monthend=",
  substr(date2, 6, 7),
  "&yearend=",
  substr(date2, 1, 4),
  "&req_city=&req_state=&req_statename=&reqdb.zip=&reqdb.magic=&reqdb.wmo=",
  sep = ""
  )
  return (URL)
}

fetchWeather <- function(startDate, endDate) {
  # Retrieve weather data for a given date range from webpage.
  # Arguments: startDate, endDate are strings representing the start and end date in the format 'YYYY/mm/dd'
  # Returns: a data frame containing the date, temperature, humidity, wind, precipitation, and types of weather

  webpage <-
    RCurl::getURL(getUrl(startDate, endDate))
  tc <- textConnection(webpage)
  webpage <- readLines(tc)
  close(tc)

  pagetree <- htmlTreeParse(webpage, useInternalNodes = TRUE)
  weatherDate <-
  unlist(xpathApply(pagetree, "//*[@id='obsTable']/tbody/tr/td[1]/a", xmlValue))

  weatherTempHi <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[2]/span",
  xmlValue
  ))

  weatherTempLo <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[4]/span",
  xmlValue
  ))

  weatherHumidity <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[9]/span",
  xmlValue
  ))

  weatherWind <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[18]/span",
  xmlValue
  ))

  weatherPrecip <-
  unlist(xpathApply(
  pagetree,
  "//*[@id='obsTable']/tbody/tr/td[20]/span",
  xmlValue
  ))

  weatherType <-
  unlist(xpathApply(pagetree, "//*[@id='obsTable']/tbody/tr/td[21]", xmlValue))

  # cleaning
  weatherType <-
  weatherType[grepl("\n", weatherType)] # remove empty strings
  weatherType <- gsub("\n", "", weatherType)
  weatherType <- gsub("\t", "", weatherType)

  weatherType
  weatherRain <- grepl("Rain", weatherType)
  weatherThunder <- grepl("Thunderstorm", weatherType)
  weatherFog <- grepl("Fog", weatherType)
  weatherSnow <- grepl("Snow", weatherType)

  weatherFrame <-
  data.frame(
  weatherDate,
  weatherTempHi,
  weatherTempLo,
  weatherHumidity,
  weatherWind,
  weatherPrecip,
  weatherType,
  weatherRain,
  weatherThunder,
  weatherFog,
  weatherSnow,
  stringsAsFactors = FALSE)

  weatherFrame[, 1:6] <- sapply(weatherFrame[, 1:6], as.numeric)

  colnames(weatherFrame) <-
  c("date",
  "tempHi",
  "tempLo",
  "avgHumidity",
  "avgWind",
  "precip",
  "type",
  "rain",
  "thunder",
  "fog",
  "snow")

  return(weatherFrame)
}

weather2016 <- fetchWeather("2016/06/23", "2017/06/22")
weather2017 <- fetchWeather("2017/06/23", "2017/12/02")
weatherTotal <- rbind(weather2016, weather2017)
weatherTotal
```

Merge activity data frame with weather data frame.
```{r}
data <- cbind(data, weatherTotal[,2:11])
data
```

Check for missing values. Only the precipitation column contains missing values.
```{r}
sapply(data[,1:14], function(x) length(x[which(is.na(x) == TRUE)]))
```

Exploratory visuals for precipitation.
```{r}
# precipitation over a one year period
plot(weather2016$precip, xlab="days since 2016/06/23", ylab="precipitation (in)")
# distribution of precipitation amounts
qplot(weatherTotal$precip,
      geom="histogram")
# distribution of non-zero precipitation amounts
qplot(weatherTotal$precip[which(weatherTotal$precip>0)],
      geom="histogram")
```

Partition data into training and validation sets.
```{r}
set.seed(200)
sampleRows <- sample.int(nrow(data), size = nrow(data)*.75)
sampleRows

trainingData <- data[sampleRows,]
trainingData <- trainingData[complete.cases(trainingData),]
trainingData

validationData <- data[-sampleRows,]
validationData <- validationData[complete.cases(validationData),]
validationData
```

Create regression model to impute missing precipitation data.
```{r}
# plot(data$precip, data$avgHumidity)
# plot(data$precip, data$avgWind)

pred <- lm(precip ~
             week +
             tempHi +
             tempLo +
             avgHumidity +
             avgWind +
             type +
             rain +
             thunder +
             fog +
             snow,
             data = trainingData)
summary(pred)
```
Backfit the model to remove statistically insignificant variables.
```{r}
pred <- lm(precip ~
             tempHi +
             tempLo +
             avgHumidity +
             avgWind +
             type,
             data = trainingData)
summary(pred)
```

```{r}
pred <- lm(precip ~
             avgHumidity +
             avgWind +
             type,
             data = trainingData)
summary(pred)
```

```{r}
pred <- lm(precip ~
             avgHumidity +
             avgWind,
             data = trainingData)
summary(pred)
```

Determine accuracy of imputation model for precipitation to be 54.26%. 
While the model is not statistically powerful with a low adjusted r-squared value .241, it serves the purpose of imputing missing precipation values.
```{r}
predAccuracy <- round(predict(pred, trainingData, type="response"))
accuracy(predAccuracy, validationData$precip)
```

Impute missing precipitation value.
```{r}
# pred$coefficients

imputePrecip <- function(r) {
  # if(r[9])
  precipPred <- (pred$coefficients[[1]] +
  (pred$coefficients[[2]] * r[7]) + (pred$coefficients[[3]] * r[8]))
  return(round(max(precipPred, 0), 2))
}

isWeatherEvent <- function(x) {# takes in a character for "type"
  return(
  x == "Rain" |
  x == "Thunderstorm" |
  x == "Fog" |
  x == "Snow" |
  x == "Fog,Rain" |
  x == "Rain,Thunderstorm" |
  x == "Fog,Rain,Thunderstorm" |
  x == "Fog,Rain,Snow" |
  x == "Fog,Snow" |
  x == "Rain,Snow" |
  x == "Rain,Snow,Thunderstorm"
  )
}


# imputePrecip <- function(p) {
#   precipPred <- (pred$coefficients[[1]] +
#   (pred$coefficients[[2]] * data[row(p)[1], 7]) + (pred$coefficients[[3]] * data[row(p)[1], 8]))
#   # return(max(precipPred, 0))
#   return (data[row(p),])
# }

incompleteCases <- data[!complete.cases(data),]



data
# zeroPrecip
# zeroPrecip$precip <- 0.00

sapply(data[,1:14], function(x) length(x[which(is.na(x) == TRUE)]))

# z$color<-y[match(z$letter, y$letter),2]
# data$precip <- sapply(data$precip, function(x) if(is.na(x)) {
#   x <-zeroPrecip[match(data$dateTime, zeroPrecip$dateTime),zeroPrecip$precip] }
# else {
#   data$precip
# }
# data

# z$color<-y[match(z$letter, y$letter),2]



######## DOESN'T WORK RN, TO DELETE
# data$precip <- sapply(data$precip, function(x) if(is.na(x) & match(data$dateTime, zeroPrecip$dateTime)) {
#   x <-zeroPrecip[match(data$dateTime, zeroPrecip$dateTime),zeroPrecip$precip] 
#   }
# else {
#   x <- data$precip
# })
######## 


incompleteCases

######## DELETED THE PRECIP COLUMN?, TO DELETE
# data[,9] <- sapply(data[,9], function(x) if (is.na(x) & !isWeatherEvent(data[,10])) {
#   x <- 0.00
# })
######## 



##### REFRESH THE PRECIP COLUMNS
data$precip <- weatherTotal$precip
data

# imputePrecip(incompleteCases[1,])
# imputePrecip(incompleteCases[2,])
# imputePrecip(incompleteCases[3,])
data$precip

data

# WORKS GOOD
# for data points where no weather events were recorded, impute precipitation of 0.00 if precipitation is NA
data[which(!isWeatherEvent(data$type)),][is.na(data[which(!isWeatherEvent(data$type)),]$precip),]$precip <- 0.00


# for data points where a weather event was recorded, impute precipitation
imputedPrecip <- sapply(1:34, function(x) imputePrecip(incompleteCases[x,])[[1]])
data[is.na(data$precip),]$precip <- imputedPrecip

data

# data[which(isWeatherEvent(data$type)),][is.na(data[which(isWeatherEvent(data$type)),]$precip),]


# data[which(!isWeatherEvent(data$type)),][is.na(data[which(!isWeatherEvent(data$type)),]$precip),]


incompleteCases <- data[is.na(data$precip),]
incompleteCases
# sapply(1:56, function(x) imputePrecip(incompleteCases[x,])[[1]])
```







